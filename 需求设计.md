# 立项原由

追求极致的体验与响应速度，一直以来都是前端要解决的核心问题。

对于速度，缓存这项解决方案已经在技术的各个领域都发挥了不可磨灭的作用。

在前端领域的开发当中，比较常见的场景是我们先请求后端 API 拿到所需的数据模型，然后进行展示，有时候这些API我们会多次重复请求，比如常见的列表页，上一页下一页切换很频繁，在这种情况下，缓存 API 数据就可以得到更好更快的速度体验。
-
当然，这仅仅是一个简单的想法，要实践它，我们还需要讨论各种细节，并给出具体的实施方案。

---

### 阶段需求

因为我们主要是缓存从后端拿到的数据，而获取数据操作通常为 GET 请求，所以基本明确我们要的事情，就是把 GET 到的数据存储到内存，然后在一定时间内重复利用。

### 解决方案

总结就是有三个需要关心的点：只缓存 GET 请求、使用内存存储、缓存具有有效期。接下来就是一个简单的实现方案：

1. 创建一个缓存对象，提供 get、set、remove 函数，可通过 kye，value 进行简单的存取操作。

2. 缓存对象可以配置全局缓存有效期，方便控制数据的实时性。

3. 接下来就是在请求接口时增加缓存的使用逻辑，为了兼容不同的请求类库，这里只提供一个 requestBefore 高阶方法进行处理。

4. requestBefore 在用户请求接口时使用，需要传入一个 key 和一个具体的请求函数。

5. 为了确保 Key 的唯一性，建议使用URL全路径(包含query参数)为 Key 缓存数据。

6. 请求函数返回 Promise，可拿到正确的响应数据，请求函数内部封装了请求过程，这样设计是为了让调用者可根据自己的需要选择喜欢的请求类库。

---

### 阶段需求

上诉方案解决了基本的缓存需求，但是在某些问题的处理上不够智能：

1. 有效期不灵活，比如有些数据的实时性要求并不高；比如有些数据不会经常改变；这些情况下的数据都可以适当的延长有效期。

2. 重复性缓存，比如一个分页列表，缓存数据的 Key 通常包含有页码和每页数量，当每页数量变化时因为 Key 不同，造成数据重复性缓存，如果列表含有搜索条件，那么重复率会更高，从而造成内存浪费或占用过高。

3. 缓存容易失效，比如一个列表，一旦有删除或新增操作，那么整个列表缓存都将失效。

4. 缓存利用率不高，比如一个总量不大或者未使用分页的列表，很容易缓存所有的数据。这时候如果用户使用需要检索某个数据，直接使用缓存数据进行检索就可以了。

### 解决方案

1. 引入类似 MongoDB 里 Collection 集合概念，并提供创建集合与删除集合的方法。

2. 有效期不灵活的问题：每个集合拥有属于自己的元数据，比如有效期元数据，可以针对性的给不同缓存设置有效时间；

3. 重复性缓存的问题：每个集合必须设置唯一主键，避免数据的重复添加，同时自动根据主键创建索引，提高删改查的效率。

4. 容易失效的问题：集合提供 insert、update、remove 增删改方法，对数据的持续维护可让缓存尽可能的持久。

5. 数据利用率低的问题：集合提供 find、findOne 查方法，增加缓存在其它情况下的复用性。为了提高查询的效率，集合还可以创建索引。

---

### 阶段需求

1. 因为缓存数据存在内存当中，那么在缓存未过期时刷新或关闭页面，会导致缓存被动丢失。

2. 最好能够控制每个 Collection 在页面刷新或关闭时是否持久化数据。

### 方案简述

1. 使用 LocalStorage 和 IndexedDB 作为数据持久化方案，优先使用 IndexedDB。

2. 监听 beforeunload 和 unload 事件捕获刷新与卸载行为，并确保当两个事件同时触发时，持久化逻辑只执行一次

---

### 阶段需求

继续优化完善上面的处理逻辑，解决如下场景问题：

1. 数据的不连续性问题：当缓存一个列表数据时，需要保证数据的连续性，否则就会获取错误数据。比如先缓存了列表的第一页数据，再缓存第三页数据，这时候如果用户访问第二页数据，就会错误的使用第三页的缓存数据。除非我们每次缓存数据时手动判断已缓存数据与当前数据是否连续(已缓存数/每页数量=已缓存页数)。

### 解决方案

1. 集合引入类型的概念，在集合创建时的元数据里进行配置。新设一个分页类型，如果为该类型，那么每次缓存新数据时根据页码与每页数量自动分析数据的连续性，如果相差页码小于2，那么自动请求中间缺失的数据进行缓存，如果大于3，则撤销这次缓存。
